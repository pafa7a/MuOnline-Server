// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.2
// source: src/messages/gameserver.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "";

export enum LoginResponseEnum {
  LOGIN_OK = 0,
  LOGIN_INVALID_CREDENTIALS = 1,
  LOGIN_INVALID_VERSION = 2,
  LOGIN_INVALID_SERIAL = 3,
  LOGIN_SERVER_FULL = 4,
  LOGIN_ALREADY_CONNECTED = 5,
  LOGIN_TOO_MANY_ATTEMPTS = 6,
  LOGIN_BANNED = 7,
  UNRECOGNIZED = -1,
}

export function loginResponseEnumFromJSON(object: any): LoginResponseEnum {
  switch (object) {
    case 0:
    case "LOGIN_OK":
      return LoginResponseEnum.LOGIN_OK;
    case 1:
    case "LOGIN_INVALID_CREDENTIALS":
      return LoginResponseEnum.LOGIN_INVALID_CREDENTIALS;
    case 2:
    case "LOGIN_INVALID_VERSION":
      return LoginResponseEnum.LOGIN_INVALID_VERSION;
    case 3:
    case "LOGIN_INVALID_SERIAL":
      return LoginResponseEnum.LOGIN_INVALID_SERIAL;
    case 4:
    case "LOGIN_SERVER_FULL":
      return LoginResponseEnum.LOGIN_SERVER_FULL;
    case 5:
    case "LOGIN_ALREADY_CONNECTED":
      return LoginResponseEnum.LOGIN_ALREADY_CONNECTED;
    case 6:
    case "LOGIN_TOO_MANY_ATTEMPTS":
      return LoginResponseEnum.LOGIN_TOO_MANY_ATTEMPTS;
    case 7:
    case "LOGIN_BANNED":
      return LoginResponseEnum.LOGIN_BANNED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoginResponseEnum.UNRECOGNIZED;
  }
}

export function loginResponseEnumToJSON(object: LoginResponseEnum): string {
  switch (object) {
    case LoginResponseEnum.LOGIN_OK:
      return "LOGIN_OK";
    case LoginResponseEnum.LOGIN_INVALID_CREDENTIALS:
      return "LOGIN_INVALID_CREDENTIALS";
    case LoginResponseEnum.LOGIN_INVALID_VERSION:
      return "LOGIN_INVALID_VERSION";
    case LoginResponseEnum.LOGIN_INVALID_SERIAL:
      return "LOGIN_INVALID_SERIAL";
    case LoginResponseEnum.LOGIN_SERVER_FULL:
      return "LOGIN_SERVER_FULL";
    case LoginResponseEnum.LOGIN_ALREADY_CONNECTED:
      return "LOGIN_ALREADY_CONNECTED";
    case LoginResponseEnum.LOGIN_TOO_MANY_ATTEMPTS:
      return "LOGIN_TOO_MANY_ATTEMPTS";
    case LoginResponseEnum.LOGIN_BANNED:
      return "LOGIN_BANNED";
    case LoginResponseEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RegisterResponseEnum {
  REGISTER_OK = 0,
  REGISTER_ERROR = 1,
  REGISTER_INVALID_INPUT = 2,
  REGISTER_INVALID_EMAIL = 3,
  REGISTER_INVALID_VERSION = 4,
  REGISTER_INVALID_SERIAL = 5,
  REGISTER_USER_EXISTS = 6,
  REGISTER_TOO_MANY_ATTEMPTS = 7,
  UNRECOGNIZED = -1,
}

export function registerResponseEnumFromJSON(object: any): RegisterResponseEnum {
  switch (object) {
    case 0:
    case "REGISTER_OK":
      return RegisterResponseEnum.REGISTER_OK;
    case 1:
    case "REGISTER_ERROR":
      return RegisterResponseEnum.REGISTER_ERROR;
    case 2:
    case "REGISTER_INVALID_INPUT":
      return RegisterResponseEnum.REGISTER_INVALID_INPUT;
    case 3:
    case "REGISTER_INVALID_EMAIL":
      return RegisterResponseEnum.REGISTER_INVALID_EMAIL;
    case 4:
    case "REGISTER_INVALID_VERSION":
      return RegisterResponseEnum.REGISTER_INVALID_VERSION;
    case 5:
    case "REGISTER_INVALID_SERIAL":
      return RegisterResponseEnum.REGISTER_INVALID_SERIAL;
    case 6:
    case "REGISTER_USER_EXISTS":
      return RegisterResponseEnum.REGISTER_USER_EXISTS;
    case 7:
    case "REGISTER_TOO_MANY_ATTEMPTS":
      return RegisterResponseEnum.REGISTER_TOO_MANY_ATTEMPTS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RegisterResponseEnum.UNRECOGNIZED;
  }
}

export function registerResponseEnumToJSON(object: RegisterResponseEnum): string {
  switch (object) {
    case RegisterResponseEnum.REGISTER_OK:
      return "REGISTER_OK";
    case RegisterResponseEnum.REGISTER_ERROR:
      return "REGISTER_ERROR";
    case RegisterResponseEnum.REGISTER_INVALID_INPUT:
      return "REGISTER_INVALID_INPUT";
    case RegisterResponseEnum.REGISTER_INVALID_EMAIL:
      return "REGISTER_INVALID_EMAIL";
    case RegisterResponseEnum.REGISTER_INVALID_VERSION:
      return "REGISTER_INVALID_VERSION";
    case RegisterResponseEnum.REGISTER_INVALID_SERIAL:
      return "REGISTER_INVALID_SERIAL";
    case RegisterResponseEnum.REGISTER_USER_EXISTS:
      return "REGISTER_USER_EXISTS";
    case RegisterResponseEnum.REGISTER_TOO_MANY_ATTEMPTS:
      return "REGISTER_TOO_MANY_ATTEMPTS";
    case RegisterResponseEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Wrapper {
  type: string;
  payload: Uint8Array;
}

export interface PlayerPositionData {
  id: string;
  x: number;
  y: number;
  z: number;
  rotationX: number;
  rotationY: number;
  rotationZ: number;
}

export interface PlayerPositions {
  localPlayer: PlayerPositionData | undefined;
  otherPlayers: PlayerPositionData[];
}

export interface PlayerJoined {
  newPlayer: PlayerPositionData | undefined;
}

export interface PlayerDisconnected {
  id: string;
}

export interface WalkRequest {
  x: number;
  y: number;
  z: number;
}

export interface MovePlayer {
  id: string;
  x: number;
  y: number;
  z: number;
}

export interface LoginRequest {
  username: string;
  password: string;
  version: string;
  serial: string;
}

export interface LoginResponse {
  responseCode: LoginResponseEnum;
}

export interface RegisterRequest {
  username: string;
  email: string;
  password: string;
  version: string;
  serial: string;
}

export interface RegisterResponse {
  responseCode: RegisterResponseEnum;
}

export interface PlayerSendChatMessage {
  message: string;
}

export interface AddChatMessage {
  id: string;
  username: string;
  message: string;
}

function createBaseWrapper(): Wrapper {
  return { type: "", payload: new Uint8Array(0) };
}

export const Wrapper: MessageFns<Wrapper> = {
  encode(message: Wrapper, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Wrapper {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWrapper();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Wrapper {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: Wrapper): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Wrapper>, I>>(base?: I): Wrapper {
    return Wrapper.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Wrapper>, I>>(object: I): Wrapper {
    const message = createBaseWrapper();
    message.type = object.type ?? "";
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBasePlayerPositionData(): PlayerPositionData {
  return { id: "", x: 0, y: 0, z: 0, rotationX: 0, rotationY: 0, rotationZ: 0 };
}

export const PlayerPositionData: MessageFns<PlayerPositionData> = {
  encode(message: PlayerPositionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.x !== 0) {
      writer.uint32(21).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(29).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(37).float(message.z);
    }
    if (message.rotationX !== 0) {
      writer.uint32(45).float(message.rotationX);
    }
    if (message.rotationY !== 0) {
      writer.uint32(53).float(message.rotationY);
    }
    if (message.rotationZ !== 0) {
      writer.uint32(61).float(message.rotationZ);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerPositionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerPositionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.z = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.rotationX = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.rotationY = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.rotationZ = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerPositionData {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
      rotationX: isSet(object.rotationX) ? globalThis.Number(object.rotationX) : 0,
      rotationY: isSet(object.rotationY) ? globalThis.Number(object.rotationY) : 0,
      rotationZ: isSet(object.rotationZ) ? globalThis.Number(object.rotationZ) : 0,
    };
  },

  toJSON(message: PlayerPositionData): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    if (message.rotationX !== 0) {
      obj.rotationX = message.rotationX;
    }
    if (message.rotationY !== 0) {
      obj.rotationY = message.rotationY;
    }
    if (message.rotationZ !== 0) {
      obj.rotationZ = message.rotationZ;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerPositionData>, I>>(base?: I): PlayerPositionData {
    return PlayerPositionData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerPositionData>, I>>(object: I): PlayerPositionData {
    const message = createBasePlayerPositionData();
    message.id = object.id ?? "";
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    message.rotationX = object.rotationX ?? 0;
    message.rotationY = object.rotationY ?? 0;
    message.rotationZ = object.rotationZ ?? 0;
    return message;
  },
};

function createBasePlayerPositions(): PlayerPositions {
  return { localPlayer: undefined, otherPlayers: [] };
}

export const PlayerPositions: MessageFns<PlayerPositions> = {
  encode(message: PlayerPositions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.localPlayer !== undefined) {
      PlayerPositionData.encode(message.localPlayer, writer.uint32(10).fork()).join();
    }
    for (const v of message.otherPlayers) {
      PlayerPositionData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerPositions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerPositions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.localPlayer = PlayerPositionData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.otherPlayers.push(PlayerPositionData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerPositions {
    return {
      localPlayer: isSet(object.localPlayer) ? PlayerPositionData.fromJSON(object.localPlayer) : undefined,
      otherPlayers: globalThis.Array.isArray(object?.otherPlayers)
        ? object.otherPlayers.map((e: any) => PlayerPositionData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlayerPositions): unknown {
    const obj: any = {};
    if (message.localPlayer !== undefined) {
      obj.localPlayer = PlayerPositionData.toJSON(message.localPlayer);
    }
    if (message.otherPlayers?.length) {
      obj.otherPlayers = message.otherPlayers.map((e) => PlayerPositionData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerPositions>, I>>(base?: I): PlayerPositions {
    return PlayerPositions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerPositions>, I>>(object: I): PlayerPositions {
    const message = createBasePlayerPositions();
    message.localPlayer = (object.localPlayer !== undefined && object.localPlayer !== null)
      ? PlayerPositionData.fromPartial(object.localPlayer)
      : undefined;
    message.otherPlayers = object.otherPlayers?.map((e) => PlayerPositionData.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlayerJoined(): PlayerJoined {
  return { newPlayer: undefined };
}

export const PlayerJoined: MessageFns<PlayerJoined> = {
  encode(message: PlayerJoined, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newPlayer !== undefined) {
      PlayerPositionData.encode(message.newPlayer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerJoined {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerJoined();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newPlayer = PlayerPositionData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerJoined {
    return { newPlayer: isSet(object.newPlayer) ? PlayerPositionData.fromJSON(object.newPlayer) : undefined };
  },

  toJSON(message: PlayerJoined): unknown {
    const obj: any = {};
    if (message.newPlayer !== undefined) {
      obj.newPlayer = PlayerPositionData.toJSON(message.newPlayer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerJoined>, I>>(base?: I): PlayerJoined {
    return PlayerJoined.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerJoined>, I>>(object: I): PlayerJoined {
    const message = createBasePlayerJoined();
    message.newPlayer = (object.newPlayer !== undefined && object.newPlayer !== null)
      ? PlayerPositionData.fromPartial(object.newPlayer)
      : undefined;
    return message;
  },
};

function createBasePlayerDisconnected(): PlayerDisconnected {
  return { id: "" };
}

export const PlayerDisconnected: MessageFns<PlayerDisconnected> = {
  encode(message: PlayerDisconnected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerDisconnected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerDisconnected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerDisconnected {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: PlayerDisconnected): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerDisconnected>, I>>(base?: I): PlayerDisconnected {
    return PlayerDisconnected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerDisconnected>, I>>(object: I): PlayerDisconnected {
    const message = createBasePlayerDisconnected();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseWalkRequest(): WalkRequest {
  return { x: 0, y: 0, z: 0 };
}

export const WalkRequest: MessageFns<WalkRequest> = {
  encode(message: WalkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalkRequest {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
    };
  },

  toJSON(message: WalkRequest): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WalkRequest>, I>>(base?: I): WalkRequest {
    return WalkRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalkRequest>, I>>(object: I): WalkRequest {
    const message = createBaseWalkRequest();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  },
};

function createBaseMovePlayer(): MovePlayer {
  return { id: "", x: 0, y: 0, z: 0 };
}

export const MovePlayer: MessageFns<MovePlayer> = {
  encode(message: MovePlayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.x !== 0) {
      writer.uint32(21).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(29).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(37).float(message.z);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MovePlayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMovePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.z = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MovePlayer {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
    };
  },

  toJSON(message: MovePlayer): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MovePlayer>, I>>(base?: I): MovePlayer {
    return MovePlayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MovePlayer>, I>>(object: I): MovePlayer {
    const message = createBaseMovePlayer();
    message.id = object.id ?? "";
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  },
};

function createBaseLoginRequest(): LoginRequest {
  return { username: "", password: "", version: "", serial: "" };
}

export const LoginRequest: MessageFns<LoginRequest> = {
  encode(message: LoginRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.serial !== "") {
      writer.uint32(34).string(message.serial);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.serial = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      serial: isSet(object.serial) ? globalThis.String(object.serial) : "",
    };
  },

  toJSON(message: LoginRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.serial !== "") {
      obj.serial = message.serial;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequest>, I>>(base?: I): LoginRequest {
    return LoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequest>, I>>(object: I): LoginRequest {
    const message = createBaseLoginRequest();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.version = object.version ?? "";
    message.serial = object.serial ?? "";
    return message;
  },
};

function createBaseLoginResponse(): LoginResponse {
  return { responseCode: 0 };
}

export const LoginResponse: MessageFns<LoginResponse> = {
  encode(message: LoginResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.responseCode !== 0) {
      writer.uint32(8).int32(message.responseCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.responseCode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginResponse {
    return { responseCode: isSet(object.responseCode) ? loginResponseEnumFromJSON(object.responseCode) : 0 };
  },

  toJSON(message: LoginResponse): unknown {
    const obj: any = {};
    if (message.responseCode !== 0) {
      obj.responseCode = loginResponseEnumToJSON(message.responseCode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginResponse>, I>>(base?: I): LoginResponse {
    return LoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginResponse>, I>>(object: I): LoginResponse {
    const message = createBaseLoginResponse();
    message.responseCode = object.responseCode ?? 0;
    return message;
  },
};

function createBaseRegisterRequest(): RegisterRequest {
  return { username: "", email: "", password: "", version: "", serial: "" };
}

export const RegisterRequest: MessageFns<RegisterRequest> = {
  encode(message: RegisterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    if (message.serial !== "") {
      writer.uint32(42).string(message.serial);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.serial = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      serial: isSet(object.serial) ? globalThis.String(object.serial) : "",
    };
  },

  toJSON(message: RegisterRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.serial !== "") {
      obj.serial = message.serial;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterRequest>, I>>(base?: I): RegisterRequest {
    return RegisterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterRequest>, I>>(object: I): RegisterRequest {
    const message = createBaseRegisterRequest();
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.version = object.version ?? "";
    message.serial = object.serial ?? "";
    return message;
  },
};

function createBaseRegisterResponse(): RegisterResponse {
  return { responseCode: 0 };
}

export const RegisterResponse: MessageFns<RegisterResponse> = {
  encode(message: RegisterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.responseCode !== 0) {
      writer.uint32(8).int32(message.responseCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.responseCode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterResponse {
    return { responseCode: isSet(object.responseCode) ? registerResponseEnumFromJSON(object.responseCode) : 0 };
  },

  toJSON(message: RegisterResponse): unknown {
    const obj: any = {};
    if (message.responseCode !== 0) {
      obj.responseCode = registerResponseEnumToJSON(message.responseCode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterResponse>, I>>(base?: I): RegisterResponse {
    return RegisterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterResponse>, I>>(object: I): RegisterResponse {
    const message = createBaseRegisterResponse();
    message.responseCode = object.responseCode ?? 0;
    return message;
  },
};

function createBasePlayerSendChatMessage(): PlayerSendChatMessage {
  return { message: "" };
}

export const PlayerSendChatMessage: MessageFns<PlayerSendChatMessage> = {
  encode(message: PlayerSendChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerSendChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerSendChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerSendChatMessage {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: PlayerSendChatMessage): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerSendChatMessage>, I>>(base?: I): PlayerSendChatMessage {
    return PlayerSendChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerSendChatMessage>, I>>(object: I): PlayerSendChatMessage {
    const message = createBasePlayerSendChatMessage();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseAddChatMessage(): AddChatMessage {
  return { id: "", username: "", message: "" };
}

export const AddChatMessage: MessageFns<AddChatMessage> = {
  encode(message: AddChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddChatMessage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: AddChatMessage): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddChatMessage>, I>>(base?: I): AddChatMessage {
    return AddChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddChatMessage>, I>>(object: I): AddChatMessage {
    const message = createBaseAddChatMessage();
    message.id = object.id ?? "";
    message.username = object.username ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
